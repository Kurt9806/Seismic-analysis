# -*- coding: utf-8 -*-
"""Numerical Methods.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y1wOFdRynsLDmZwv4S_o51FcLJw2l_FE
"""

import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt

"""# Central Method"""

# Start with initial conditions
m=0.2533
k=10
wn = 6.283
psi = 0.05

delta_t=0.1

# Calculate the coeficients
a = psi*wn
wd = wn*math.sqrt(1-psi**2)

A = math.e**(-a*delta_t)*(psi/(math.sqrt(1-psi**2))*math.sin(wd*delta_t)+math.cos(wd*delta_t))
B = math.e**(-a*delta_t)*(1/wd*math.sin(wd*delta_t))
C = 1/k*(2*psi/(wn*delta_t)+math.e**(-a*delta_t)*(((1-2*psi**2)/(wd*delta_t)-psi/math.sqrt(1-psi**2))*math.sin(wd*delta_t)-(1+2*psi/(wn*delta_t))*math.cos(wd*delta_t)))
D = 1/k*(1-2*psi/(wn*delta_t)+math.e**(-a*delta_t)*((2*psi**2-1)/(wd*delta_t)*math.sin(wd*delta_t)+2*psi/(wn*delta_t)*math.cos(wd*delta_t)))
A_ = -math.e**(-a*delta_t)*(wn/math.sqrt(1-psi**2)*math.sin(wd*delta_t))
B_ = math.e**(-a*delta_t)*(math.cos(wd*delta_t)-psi/math.sqrt(1-psi**2)*math.sin(wd*delta_t))
C_ = 1/k*(-1/delta_t+math.e**(-a*delta_t)*((wn/math.sqrt(1-psi**2)+psi/(delta_t*math.sqrt(1-psi**2)))*math.sin(wd*delta_t)+1/delta_t*math.cos(wd*delta_t)))
D_ = 1/(k*delta_t)*(1-math.e**(-a*delta_t)*(psi/math.sqrt(1-psi**2)*math.sin(wd*delta_t)+math.cos(wd*delta_t)))

# Define the force equation
P = [10*math.sin(math.pi*x/0.6) for x in np.arange(0,0.6,0.1)]
for i in range(4):
  P.append(0)
ti = np.arange(0,1,delta_t)

u = np.zeros(len(ti))
u_ = np.zeros(len(ti))

for i in range(len(ti)-1):
  u[i+1] = A*u[i] + B*u_[i] + C*P[i] + D*P[i+1]
  u_[i+1] = A_*u[i] + B_*u_[i] + C_*P[i] + D_*P[i+1]

Table = {"Time":ti,"P":P,"Velocity":u_, "Position":u}
df = pd.DataFrame.from_dict(Table)
print(df)

plt.plot(df.Time,df.Position)

"""# Central Difference Method"""

# Start with initial conditions
m=0.2533
k=10
wn = 6.283
psi = 0.05
c=0.1592

ti = np.arange(0,1,delta_t)

delta_t=0.1

u= np.zeros(len(ti))
u_1 = np.zeros(len(ti))
u_= np.zeros(len(ti))
u__ = np.zeros(len(ti))

# Initial calculations
u__[0] = (P[0]-c*u_[1]-k*u[1])/m
u_1[0] = u[0] - delta_t*u_[0] + delta_t**2/2 * u__[0]
k_ = m/(delta_t**2)+c/(2*delta_t)
a = m/(delta_t**2) - c/(2*delta_t)
b = k - 2*m/(delta_t**2)

# Iterate the calculations
P_ = np.zeros(len(ti))

for i in range(len(ti)-1):
  P_[i] = P[i]-a*u_1[i]-b*u[i]
  u[i+1] = P_[i]/k_
  u_1[i+1] = u[i]
  u_[i]=(u[i+1]-u[i-1])/(2*delta_t)
  u__[i]=(u[i+1]-2*u[i]+u[i-1])/(delta_t**2)

Table1 = {"Time":ti,"P":P,"Ui-1":u_1,"Position":u,"P hat":P_}
df1 = pd.DataFrame.from_dict(Table1)
print(df1)

plt.plot(df1.Time,df.Position)

"""# Newmark Method"""

# Start with initial conditions
m=0.2533
k=10
wn = 6.283
psi = 0.05
c=0.1592

ti = np.arange(0,1.1,delta_t)

delta_t=0.1

# Define constants
Method = {"constante":{beta:1/4,gamma:1/2},"lineal":{beta:1/6, gamma:1/2}}

Option = "lineal"
beta = Method[Option][beta]
gamma = Method[Option][gamma]

# Start vectors
u= np.zeros(len(ti))
u_= np.zeros(len(ti))
u__ = np.zeros(len(ti))
P_ = np.zeros(len(ti))

# Initial Parameters
u__[0]=(P[0]-c*u_[0]-k*u[0])/m
a1 = 1/(beta*delta_t**2)*m+gamma/(beta*delta_t)*c
a2 = 1/(beta*delta_t)*m+(gamma/beta-1)*c
a3 = (1/(2*beta)-1)*m+delta_t*(gamma/(2*beta)-1)*c
k_ = k+a1

# Start iteration
for i in range(len(ti)-1):
  P_[i+1] = P[i+1]+a1*u[i]+a2*u_[i]+a3*u__[i]
  u[i+1] = P_[i+1]/k_
  u_[i+1] = gamma/(beta*delta_t)*(u[i+1]-u[i])+(1-gamma/beta)*u_[i]+delta_t*(1-gamma/(2*beta))*u__[i]
  u__[i+1] = 1/(beta*delta_t**2)*(u[i+1]-u[i])-1/(beta*delta_t)*u_[i]-(1/(2*beta)-1)*u__[i]

Table2 = {"Time":ti,"P":P,"Position":u,"P hat":P_}
df2 = pd.DataFrame.from_dict(Table2)
print(df2)